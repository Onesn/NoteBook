## 02 | App 启动速度怎么做优化与监控？
![](https://static001.geekbang.org/resource/image/1c/ac/1cc1b628ba41809b9ee801055150c1ac.jpg)

### App启动时都干了些什么事？
一般情况下，App的启动分为**冷启动和热启动。**
- **冷启动是指**，App点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。
- **热启动是指**，App在冷启动后用户将App退后台，在App的进程还在系统里的情况下，用户重新启动进入App的过程，这个过程做的事情非常少。

用户能感知到的启动慢，其实都发生在主线程上。而主线程慢的原因有很多，比如在主线程上执行了大文件读写操作、在渲染周期中执行了大量计算等。

一般而言，App的启动时间，指的是从用户点击App开始，到用户看到第一个界面之间的时间。总结来说，App的启动主要包括三个阶段：
- **1.main()函数执行前；**
- **2.main()函数执行后；**
- **3.首屏渲染完成后。**

整个启动过程的示意图：
![启动过程](https://static001.geekbang.org/resource/image/8a/81/8af7e23cd98c8add88e2f8ed3405ed81.png)

### main()函数执行前
在main()函数执行前，系统主要会做下面几件事情：
- 加载可执行文件（App的.o文件的集合）；
- 加载动态链接库，进行rebase指针调整和bind符号绑定；
- Objc运行时的初始处理，包括Objc相关类的注册、category注册、selector唯一性检查等；
- 初始化，包含了执行+load()方法、attribute((constructor))修饰的函数的调用、创建C++静态全局变量。

相应地，这个阶段对于启动速度优化来说，可以做的事情包括：
- 减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，最多可以支持6个非系统动态库合并为一个。
- 减少加载启动后不会去使用的类或者方法。
- +load()方法里的内容可以放到首屏渲染完成之后再执行，或使用+initialize()方法替换掉。
- 控制C++全局变量的数量。

### main()函数执行后
main()函数执行后的阶段，指的是从main()函数执行开始，到AppDelegate的didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。

首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括了：
- 首屏初始化所需配置文件的读写操作；
- 首屏列表大数据的读取；
- 首屏渲染的大量计算等。

### 首屏渲染完成后
首屏渲染后的这个阶段，主要完成的是，非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等。从函数上来看，这个阶段指的就是截至到didFinishLaunchingWithOptions方法作用域内执行首屏渲染之后的所有方法执行完成。简单来说，这个阶段就是从渲染完成时开始，到didFinishLaunchingWithOptions方法作用域结束时结束。

### 功能级别的启动优化
功能级别的启动优化，就是要从main()函数执行后这个阶段下手。

优化的思路是：main()函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。如图所示：
![功能级别的启动优化示意图](https://static001.geekbang.org/resource/image/f3/19/f30f438d447e81132dd520e657427419.png)

### 方法级别的启动优化
经过功能级别的启动优化，也就是将非首屏业务所需的功能滞后以后，从用户点击App到看到首屏的时间将会有很大程度的缩短，也就达到了优化App启动速度的目的。

在这之后，我们需要进一步做的，是检查首屏渲染完成前主线程上有哪些耗时方法，将没必要的耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体表现就是加载、编辑、存储图片和文件资源等。

类似单个方法耗时不多，但是由于堆积导致App启动速度大幅变慢的方法数不胜数。所以，你需要一个能够对启动方法耗时进行全面检查、精确检查的手段。

目前来看，对App启动速度的监控，主要有两种手段。

**第一种方法是，定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时。**Xcode工具套件里自带的Time Profiler,采用的就是这种方式。

这种方式的优点是，开发类似工具成本不高，能够快速开发后集成到你的App中，以便在真实环境中进行检查。

说到定时抓取，就会涉及到定时间隔的长短问题。
- 定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确；
- 而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确。

总结来说，定时抓取主线程调用栈的方式虽然精确度不够高，但也是够用的。

**第二种方法是，对objc_msgSend方法进行hook来掌握所有方法的执行耗时。**

hook方法的意思是，在原方法开始执行时换成执行其他你指定的方法，或者在原有方法执行前后执行你指定的方法，来达到掌握和改变指定方法的目的。

hook objc_msgSend这种方式的优点就是非常精确，而缺点是只能针对Objective-C的方法。当然，对于c方法和block也不是没有办法，可以使用libffi的ffi_call来达成hook，但是编写维护相关工具门槛高。

综上，对于检查结果要求高的话，使用hook objc_msgSend方式来检查启动方法的执行耗时。

### 如何做一个方法级别启动耗时检查工具来辅助分析和监控？

Objective-C里每个对象都会指向一个类，每个类都会有一个方法列表，方法列表里的每个方法都是由selector、函数指针和metadata组成的。

objc_msgSend方法干的活，就是在运行时根据对象和方法的selector去找对应的函数指针，然后执行。也就是说，objc_msgSend是Objective-C里方法执行的必经之路，能够控制所有的Objective-C的方法。

objc_msgSend本身是用汇编语言写的，这样做的原因主要有两个：
- objc_msgSend的调用频次最高，在它上面进行的性能优化能够提升整个App的生命周期的性能。而汇编语言在性能优化上属于原子级优化，能后把优化做到极致。
- 其他语言难以实现未知参数跳转到任意函数指针的功能。

objc_msgSend方法执行的逻辑是：先获取对象对应类的信息，再获取方法的缓存，根据方法的selector查找函数指针，经过异常错误处理后，最后跳转到对应函数的实现。[msgSend源码](https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/)

**怎么hook objc_msgSend方法？**

Facebook开源了一个库，可以在iOS上运行的Mach-O二进制文件中动态地重新绑定符号，查看[fishhook 的代码](https://github.com/facebook/fishhook)。

fishbook实现的大致思路是，通过重新绑定符号，可以实现对c方法的hook。dyld是通过更新Mach-O二进制的__DATA segment特定的部分中的指针来绑定lazy和non-lazy符号，通过确认传递给rebind_symbol里每个符号名称更新的位置，就可以找出对应替换来重新绑定这些符号。


